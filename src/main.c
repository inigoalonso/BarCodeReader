#pragma config(Sensor, S1,     touchSensor,         sensorTouch)
#pragma config(Sensor, S2,     soundSensor,         sensorSoundDB)
#pragma config(Sensor, S3,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
#pragma config(Motor,  motorA,          putter,        tmotorNormal, PIDControl, )
#pragma config(Motor,  motorB,          leftMotor,    tmotorNormal, PIDControl, )
#pragma config(Motor,  motorC,          rightMotor,     tmotorNormal, PIDControl, )
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


// Copyright (c) 2009, Iñigo Alonso Fernández <inigolonso@inigoalonso.com>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Iñigo Alonso Fernández nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY IÑIGO ALONSO FERNÁNDEZ ''AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL IÑIGO ALONSO FERNÁNDEZ BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


//Declaracion e inicializacion de variables
bool orders        = true;
bool messageEnd    = false;
bool messageBegin  = false;
bool stripEnd      = false;
bool stripBegin    = false;
int initialLight   = 0;
int degrees        = 0;
int initialDegrees = 0;
int actualLight    = 100;
int deltaDegrees   = 0;
int orderNumber    = 0;


//Moverse hacia delante (despacito para poder leer)
void moveSlow()
{
	motor[motorB] = 9;
	motor[motorC] = 9;
	wait1Msec(10);
}

//Mover marcha atras
void moveBack()
{
	motor[motorB] = -9;
	motor[motorC] = -9;
	wait1Msec(10);
}

//Parar los motores
void moveStop()
{
	motor[motorB] = 0;
	motor[motorC] = 0;
}

//Girar
void moveTurn(int turn)		//Positivo hacia la derecha
{
	if (turn > 0)
	{
		motor[motorB] = 9;
		motor[motorC] = -5;
	}
	else
	{
		motor[motorB] = -5;
		motor[motorC] = 9;
	}
	wait1Msec(abs(30*turn)); //Numero magico
	moveStop();
}

//Ejecutar orden
void order(int orderNumber)
{
	switch (orderNumber)
	{
		case 0: //Orden inicial, avanzar
			moveSlow();
			break;

		case 101: //Avanzar hasta obstáculo, chutar hacia derecha y girar 90 grados hacia izquierda
			while (SensorValue(sonarSensor) > 26)
			{
				nxtDisplayCenteredTextLine(3, "Distancia: %d", SensorValue(sonarSensor));
				moveSlow();
			}
			motor[motorA] = -25;
			wait1Msec(500);
			motor[motorA] = 0;
			wait1Msec(500);
			moveBack();
			wait1Msec(2500);
			moveStop();
			moveTurn(-90);
			break;

		case 110: //Avanzar hasta obstáculo, chutar hacia izquierda y girar 90 grados hacia derecha
			while (SensorValue(sonarSensor) > 26)
			{
				nxtDisplayCenteredTextLine(3, "Distancia: %d", SensorValue(sonarSensor));
				moveSlow();
			}
			motor[motorA] = 25;
			wait1Msec(500);
			motor[motorA] = 0;
			wait1Msec(500);
			moveBack();
			wait1Msec(2500);
			moveStop();
			moveTurn(90);
			break;

		case 102: //Avanzar hasta obstáculo y girar 180 grados
			while (SensorValue(sonarSensor) > 30)
			{
				nxtDisplayCenteredTextLine(3, "Distancia: %d", SensorValue(sonarSensor));
				moveSlow();
			}
			moveTurn(180);
			break;

		case 111: //Avanzar hasta obstáculo y girar 90 grados hacia derecha
			while (SensorValue(sonarSensor) > 30)
			{
				nxtDisplayCenteredTextLine(3, "Distancia: %d", SensorValue(sonarSensor));
				moveSlow();
			}
			moveTurn(90);
			break;

		case 120: //Avanzar hasta obstáculo y girar 90 grados hacia izquierda
			while (SensorValue(sonarSensor) > 30)
			{
				nxtDisplayCenteredTextLine(3, "Distancia: %d", SensorValue(sonarSensor));
				moveSlow();
			}
			moveTurn(-90);
			break;

		case 103: //Giro 45 grados hacia derecha
			moveTurn(45);
			break;

		case 112: //Giro 45 grados hacia izquierda
			moveTurn(-45);
			break;

		case 121: //Giro 90 grados hacia derecha
			moveTurn(90);
			break;

		case 130: //Giro 90 grados hacia izquierda
			moveTurn(-90);
			break;

		case 104: //Giro 180 grados hacia derecha
			moveTurn(180);
			break;

		case 113: //Giro 180 grados hacia derecha y marcha atrás
			moveTurn(180);
			moveBack();
			break;

		case 122: //Libre
			moveSlow();
			break;

		case 131: //Libre
			moveSlow();
			break;

		case 140: //Libre
			moveSlow();
			break;

		case 1000: //Parada
			moveStop();
			break;

		default:   //Por defecto
			moveSlow();
	}
}



task main()
{
	//Limpiar la pantalla
	eraseDisplay();
	wait1Msec(100);
	//Tomar valor inicial de la luz (se supone claro/blanco)
	initialLight = SensorValue(lightSensor);
	nxtDisplayCenteredTextLine(3, "Luz inicial: %d", initialLight);
	//Habilitar el control PID para los motores del robot
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	//hasta que se quede sin ordenes
	while(orders)
	{
		messageEnd = false;
		//hasta que se acabe un mensaje
		while(!messageEnd)
		{
			//iniciar movimiento
			order(orderNumber);
			//comprobar si empieza un mensaje (si empieza una zona oscura)
			if (SensorValue(lightSensor) <= initialLight/1.1)
				messageBegin = true;
			//lectura y ejecucion del mensaje
			while (messageBegin && !messageEnd)
			{
				actualLight = SensorValue(lightSensor);
				initialDegrees = nMotorEncoder[motorC];
				if (actualLight <= initialLight/1.1)
				{
					stripBegin = true;
					stripEnd = false;
				}
				while (stripBegin && !stripEnd)
				{
					actualLight = SensorValue(lightSensor);
					//esta negro y vamos a medir cuanto se mueve
					degrees = nMotorEncoder[motorC];
					deltaDegrees = degrees-initialDegrees;
					//Si vuelve a clarear
					if (actualLight > initialLight/1.05)
					{
						//Discernir el ancho de la banda
						if (deltaDegrees < 10)						//Ignorar
						{
							orderNumber = 0;
						}
						else
						{
							if (deltaDegrees < 40)					//1cm
							{
								orderNumber = orderNumber + 1;
							}
							else
							{
								if (deltaDegrees < 60)				//2cm
								{
									orderNumber = orderNumber + 10;
								}
								else
								{
									if (deltaDegrees < 75)			//3cm
									{
										orderNumber = orderNumber + 100;
									}
									else					//Fuera de pista
									{
										orderNumber = 1000;
									}
								}
							}
						}
						stripEnd = true;
						stripBegin = false;
					}
				}
				nxtDisplayCenteredTextLine(3, "Orden: %d", orderNumber);
				//Fin de mensaje?
				if (orderNumber >= 100)
				{
					messageEnd = true;
					messageBegin = false;
				}
			}
			//Interpretar mensaje y ejecutar su orden
			order(orderNumber);
			//
			orders = false;
			orderNumber = 0;
		}
		//Pitar para avisar del fin de la ejecucion de las ordenes
		PlayTone(420, 50);
		//Esperar (durante 5s) un sonido fuerte para continuar (p.e. palmada)
		ClearTimer(T1);	//Inicia temporizador
		while(time10(T1) < 500 && !orders)
		{
			if(SensorValue(soundSensor) >= 50)
			{
				orders = true;
			}
			else
			{
				nxtDisplayCenteredTextLine(3, "Sin ordenes");
			}
		}
	}
}
